import React, { useState, useRef } from 'react';
import { CheckIcon, ClipboardCopyIcon, DownloadIcon, FileText } from 'lucide-react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { logger } from '../utils/logger';
import type { Template } from '../types';

// 添加类型定义
interface CodeProps {
  inline?: boolean;
  className?: string;
  children: React.ReactNode;
}

interface TableRowData {
  text: string;
  [key: string]: any;
}

interface OutputDisplayProps {
  isLoading: boolean;
  output: string | null;
  template?: Template;
  language: string;
}

const OutputDisplay: React.FC<OutputDisplayProps> = ({ isLoading, output, template, language }) => {
  const [copied, setCopied] = useState(false);
  const [showDownloadOptions, setShowDownloadOptions] = useState(false);
  const outputRef = useRef<HTMLDivElement>(null);
  const [error, setError] = useState<string | null>(null);
  const [codeBlockCopied, setCodeBlockCopied] = useState<string | null>(null);
  
  const handleCodeBlockCopy = (code: string) => {
    navigator.clipboard.writeText(code);
    setCodeBlockCopied(code);
    setTimeout(() => setCodeBlockCopied(null), 2000);
  };

  const formatOutput = (text: string | null | undefined): string => {
    try {
      if (!text) return '';
      let textStr = String(text);
      
      // 检查是否已经是JSON对象
      if (typeof text === 'object') {
        try {
          const content = text.content || text;
          return typeof content === 'string' ? content : JSON.stringify(content, null, 2);
        } catch (e) {
          return String(text);
        }
      }
      
      // 尝试解析JSON字符串
      try {
        if (textStr.trim().startsWith('{') || textStr.trim().startsWith('[')) {
          const jsonData = JSON.parse(textStr);
          if (jsonData.content) {
            return jsonData.content;
          }
          return '```json\n' + JSON.stringify(jsonData, null, 2) + '\n```';
        }
      } catch {
        // 如果解析失败，返回原始文本
      }

      return textStr;
    } catch (e) {
      logger.error('格式化输出失败', e);
      return '';
    }
  };
  
  // 动态插入版权信息函数
  const addCopyrightFooter = (content: string, format: string = 'md'): string => {
    // 根据当前语言选择版权信息
    const copyrightText = language === 'zh' ? 
      '本文件由 [ProductMind AI](https://productmindai.com) 生成' : 
      'Generated by [ProductMind AI](https://productmindai.com)';
    
    let footer = '';
    
    switch (format) {
      case 'md':
        footer = `

---
${copyrightText}
`;
        break;
      default:
        footer = `

---
${copyrightText}
`;
    }
    
    return content + footer;
  };
  
  const copyToClipboard = async () => {
    if (!output) return;
    
    try {
      await navigator.clipboard.writeText(output);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
      logger.log('内容已复制到剪贴板');
    } catch (err) {
      logger.error('复制到剪贴板失败', err);
      setError('复制失败，请重试');
      setTimeout(() => setError(null), 3000);
    }
  };
  
  // 将 Markdown 转换为 Word 文档结构
  const convertMarkdownToDocx = async (markdown: string) => {
    try {
      // 首先使用 formatOutput 处理输入内容
      const formattedContent = formatOutput(markdown);
      // 确保 markdown 是字符串类型
      const markdownStr = String(formattedContent);
      const tokens = marked.lexer(markdownStr);
      const docElements = [];
      
      for (const token of tokens) {
        switch (token.type) {
          case 'heading':
            docElements.push(
              new Paragraph({
                text: token.text,
                heading: token.depth === 1 ? HeadingLevel.HEADING_1 : 
                         token.depth === 2 ? HeadingLevel.HEADING_2 : HeadingLevel.HEADING_3,
                spacing: {
                  before: 240,
                  after: 120
                }
              })
            );
            break;

          case 'paragraph':
            docElements.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: token.text,
                    size: 24
                  })
                ],
                spacing: {
                  before: 120,
                  after: 120
                }
              })
            );
            break;

          case 'code':
            docElements.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: token.text,
                    font: 'Courier New',
                    size: 20
                  })
                ],
                spacing: {
                  before: 120,
                  after: 120
                },
                shading: {
                  type: 'clear',
                  fill: 'F8F9FA'
                }
              })
            );
            break;

          case 'table':
            if ('rows' in token) {
              const rows = (token.rows as TableRowData[][]).map(row =>
                new TableRow({
                  children: row.map(cell =>
                    new TableCell({
                      children: [new Paragraph({ text: String(cell) })],
                      width: {
                        size: 100 / row.length,
                        type: WidthType.PERCENTAGE
                      }
                    })
                  )
                })
              );

              docElements.push(
                new Table({
                  rows,
                  width: {
                    size: 100,
                    type: WidthType.PERCENTAGE
                  },
                  borders: {
                    top: { style: BorderStyle.SINGLE, size: 1 },
                    bottom: { style: BorderStyle.SINGLE, size: 1 },
                    left: { style: BorderStyle.SINGLE, size: 1 },
                    right: { style: BorderStyle.SINGLE, size: 1 }
                  }
                })
              );
            }
            break;

          case 'list':
            if ('items' in token) {
              token.items.forEach((item: any, index: number) => {
                docElements.push(
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: `${index + 1}. ${item.text}`,
                        size: 24
                      })
                    ],
                    spacing: {
                      before: 60,
                      after: 60
                    }
                  })
                );
              });
            }
            break;
        }
      }

      return new Document({
        sections: [{
          properties: {},
          children: docElements
        }]
      });
    } catch (error) {
      logger.error('转换Word文档失败', error);
      throw error;
    }
  };

  // 添加文件名格式化函数
  const formatFileName = (extension: string) => {
    const date = new Date().toISOString().slice(0, 10);
    const version = `v${date.replace(/-/g, '')}`;
    
    logger.log('开始格式化文件名', {
      templateInfo: {
        id: template?.id,
        name_zh: template?.name_zh,
        name_en: template?.name_en,
        project: template?.project,
        currentProject: template?.currentProject
      },
      currentLanguage: language
    });

    let fileName = '';
    // Get language-dependent template name
    const templateName = (language === 'zh' ? template?.name_zh : template?.name_en)?.replace(/[^\w\u4e00-\u9fa5-]/g, '') || 'template';
    
    if (template?.currentProject) {
      // Get project name from currentProject
      const projectName = template.currentProject.name?.replace(/[^\w\u4e00-\u9fa5-]/g, '') || 'project';
      
      logger.log('文件名组成部分', {
        projectName,
        templateName,
        version,
        extension
      });

      fileName = `${projectName}-${templateName}-${version}`;
    } else {
      logger.log('未找到项目信息，仅使用模板名称', {
        templateName,
        version
      });
      fileName = `${templateName}-${version}`;
    }
    
    logger.log('最终生成的文件名', { fileName: `${fileName}.${extension}` });
    return `${fileName}.${extension}`;
  };

  // 修改下载为 Markdown 函数
  const downloadAsMarkdown = () => {
    if (!output) return;
    
    try {
      logger.log('开始生成Markdown文件', {
        templateInfo: template,
        outputLength: output.length
      });

      const formattedContent = formatOutput(output);
      const contentWithFooter = addCopyrightFooter(formattedContent, 'md');
      
      const element = document.createElement('a');
      const file = new Blob([contentWithFooter], { type: 'text/plain' });
      element.href = URL.createObjectURL(file);
      const fileName = formatFileName('md');
      
      logger.log('Markdown文件生成完成', {
        fileName,
        contentLength: contentWithFooter.length
      });

      element.download = fileName;
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
      URL.revokeObjectURL(element.href);
      setShowDownloadOptions(false);
    } catch (err) {
      logger.error('下载Markdown失败', {
        error: err,
        template: template,
        outputLength: output?.length
      });
      setError('下载失败，请重试');
      setTimeout(() => setError(null), 3000);
    }
  };

  // 修改下载按钮部分的渲染
  const renderDownloadButton = () => (
    <div className="relative">
      <button
        onClick={() => setShowDownloadOptions(!showDownloadOptions)}
        disabled={!output}
        className="inline-flex items-center px-3 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50"
        title="下载分析报告"
      >
        <div className="flex items-center space-x-1">
          <DownloadIcon className="h-4 w-4" />
          <span>下载</span>
        </div>
      </button>
      
      {showDownloadOptions && output && (
        <div className="absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg ring-1 ring-black ring-opacity-5 z-10">
          <div className="py-1" role="menu" aria-orientation="vertical">
            <button
              onClick={downloadAsMarkdown}
              className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
              role="menuitem"
            >
              {language === 'zh' ? '下载为 Markdown (.md)' : 'Download as Markdown (.md)'}
            </button>
          </div>
        </div>
      )}
    </div>
  );

  if (!template && !isLoading && !output) return null;

  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden">
      <div className="bg-gray-50 px-6 py-4 border-b border-gray-200 relative">
        <div className="flex justify-between items-center space-x-4">
          <div className="flex items-center space-x-3">
            <div className="p-2 rounded-lg bg-indigo-600 text-white">
              <FileText className="h-5 w-5" />
            </div>
            <div>
              <h3 className="text-lg font-medium text-gray-900 flex items-center space-x-3">
                <span>分析结果</span>
                {isLoading && (
                  <div className="animate-spin h-4 w-4 border-2 border-indigo-600 border-t-transparent rounded-full"></div>
                )}
              </h3>
              {template && (
                <p className="text-sm text-gray-500 mt-1">
                  {template.name_zh} · {template.description_zh}
                </p>
              )}
            </div>
          </div>
          <div className="flex space-x-2">
            <button
              onClick={copyToClipboard}
              disabled={!output}
              className="inline-flex items-center px-3 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50"
              title="复制到剪贴板"
            >
              {copied ? (
                <div className="flex items-center space-x-1">
                  <CheckIcon className="h-4 w-4 text-green-500" />
                  <span>已复制</span>
                </div>
              ) : (
                <div className="flex items-center space-x-1">
                  <ClipboardCopyIcon className="h-4 w-4" />
                  <span>复制</span>
                </div>
              )}
            </button>
            {renderDownloadButton()}
          </div>
        </div>
        {error && (
          <div className="mt-2 p-2 bg-red-50 text-red-600 text-sm rounded">
            {error}
          </div>
        )}
      </div>
      
      <div className="p-6">
          <div 
            ref={outputRef} 
            className="prose max-w-none overflow-auto max-h-[400px]"
          > 
            <ReactMarkdown
              remarkPlugins={[remarkGfm]}
              components={{
                code({ inline, className, children, ...props }: CodeProps) {
                  const code = String(children).replace(/\n$/, '');
                  
                  if (inline) {
                    return <code className="px-1.5 py-0.5 bg-white border border-indigo-100 rounded text-gray-900 font-mono text-sm" {...props}>{code}</code>;
                  }

                  return (
                    <div className="relative group">
                      <pre className={`${className || ''} bg-white border border-indigo-100 rounded-lg p-4 overflow-x-auto`}>
                        <code className="text-gray-900 font-mono text-sm" {...props}>{code}</code>
                      </pre>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          handleCodeBlockCopy(code);
                        }}
                        className="absolute top-2 right-2 p-1 text-gray-400 hover:text-gray-600 opacity-0 group-hover:opacity-100 transition-opacity"
                        title="复制代码"
                      >
                        {codeBlockCopied === code ? (
                          <CheckIcon className="h-4 w-4 text-green-500" />
                        ) : (
                          <ClipboardCopyIcon className="h-4 w-4" />
                        )}
                      </button>
                    </div>
                  );
                },
                table({ children }) {
                  return (
                    <div className="overflow-x-auto">
                      <table className="min-w-full divide-y divide-indigo-100 border border-indigo-100 rounded">
                        {children}
                      </table>
                    </div>
                  );
                },
                th({ children }) {
                  return (
                    <th className="px-4 py-2 text-left text-sm font-medium text-gray-900 bg-indigo-50 border-b border-indigo-100">
                      {children}
                    </th>
                  );
                },
                td({ children }) {
                  return (
                    <td className="px-4 py-2 text-sm text-gray-700 border-b border-indigo-100">
                      {children}
                    </td>
                  );
                }
              }}
            >
              {formatOutput(output)}
            </ReactMarkdown>
          </div>
      </div>
    </div>
  );
};

export default OutputDisplay;